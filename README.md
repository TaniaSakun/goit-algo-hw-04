# goit-algo-hw-04
The repository for the 4th GoItNeo homework

Під час проведення тестування було отримано наступні результати:

| Algorithm      |       Small |      Medium |       Large |
|:---------------|------------:|------------:|------------:|
| Insertion Sort | 0.000231791 | 0.0132977   |  1.28423    |
| Merge Sort     | 0.00152808  | 0.0200124   |  0.323584   |
| Quicksort      | 0.001168    | 0.0132995   |  0.106083   |
| Bubble Sort    | 0.00341346  | 0.435344    | 53.0501     |
| Timsorted      | 1.7084e-05  | 0.000106125 |  0.00115258 |
| Timsort        | 1.4375e-05  | 9.3042e-05  |  0.00132404 |

Звідси можна зробити кілька висновків:

# Час виконання
Найшвидшими алгоритмами сортування є Timsorted і Timsort, що використовують удосконалені версії алгоритму сортування злиттям. Вони мають найменший час виконання на всіх об'ємах даних. На середньому обсязі даних час виконання Timsort навіть нижчий, ніж у Timsorted, що може бути результатом використання більш оптимізованої реалізації.

# Ефективність при збільшенні обсягу даних 
Видно, що час виконання Insertion Sort, Bubble Sort і Timsorted зростає значно швидше, ніж у Merge Sort і Quicksort, коли обсяг даних зростає. Це свідчить про те, що Insertion Sort, Bubble Sort і Timsorted менш ефективні при сортуванні великих обсягів даних порівняно з Merge Sort і Quicksort.

# Результати на великому обсязі даних 
Для великого обсягу даних, наприклад, Large, Bubble Sort має найгірший час виконання, що робить його непрактичним для використання на великих даних через його квадратичну складність. Натомість, Merge Sort і Quicksort продемонстрували кращі результати на великих обсягах даних, що робить їх більш практичними для застосування.

# Загальний висновок 
У випадку, якщо необхідно використовувати сортування на великих обсягах даних, слід віддавати перевагу алгоритмам, які мають лінійно-логарифмічний (O(n log n)) час виконання, таким як Merge Sort і Quicksort. Для менших обсягів даних, можна використовувати більш прості алгоритми, такі як Insertion Sort або Bubble Sort, але слід мати на увазі їх обмежену ефективність на великих даних.